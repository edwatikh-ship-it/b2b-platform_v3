from datetime import datetime
from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from app.adapters.db.models import RequestKeyModel, RequestModel, RequestRecipientModel
from app.domain.ports import RequestRepositoryPort


class RequestRepository(RequestRepositoryPort):
    def __init__(self, session: AsyncSession) -> None:
        self._session = session

    async def create_draft(self, title: str | None, keys: list[dict]) -> int:
        req = RequestModel(title=title, filename=None, status="draft")
        self._session.add(req)
        await self._session.flush()

        for k in keys:
            self._session.add(
                RequestKeyModel(
                    request_id=req.id,
                    pos=int(k["pos"]),
                    text=str(k["text"]),
                    qty=k.get("qty"),
                    unit=k.get("unit"),
                )
            )

        await self._session.commit()
        return int(req.id)

    async def list_requests(self, limit: int, offset: int) -> dict:
        total = await self._session.scalar(select(func.count()).select_from(RequestModel))

        rows = await self._session.execute(
            select(RequestModel)
            .order_by(RequestModel.id.desc())
            .limit(limit)
            .offset(offset)
        )
        items = []
        for r in rows.scalars().all():
            items.append(
                {
                    "id": int(r.id),
                    "filename": r.filename,
                    "status": r.status,
                    "createdat": r.created_at.isoformat() if getattr(r, "created_at", None) else None,
                    "keyscount": 0,
                }
            )

        return {"items": items, "total": int(total or 0)}

    async def get_detail(self, request_id: int) -> dict | None:
        req = await self._session.get(RequestModel, request_id)
        if req is None:
            return None

        rows = await self._session.execute(
            select(RequestKeyModel).where(RequestKeyModel.request_id == request_id).order_by(RequestKeyModel.pos.asc())
        )
        keys = []
        for k in rows.scalars().all():
            keys.append(
                {
                    "id": int(k.id),
                    "pos": int(k.pos),
                    "rawtext": str(k.text),
                    "normalizedtext": str(k.text),
                    "qty": float(k.qty) if k.qty is not None else None,
                    "unit": k.unit,
                    "suppliers": [],
                }
            )

        return {
            "id": int(req.id),
            "filename": req.filename,
            "status": req.status,
            "createdat": req.created_at.isoformat() if getattr(req, "created_at", None) else None,
            "keys": keys,
        }

    async def update_keys(self, request_id: int, keys: list[dict]) -> None:
        # Ensure request exists
        req = await self._session.get(RequestModel, request_id)
        if req is None:
            raise ValueError("not_found")

        # Replace strategy: delete all keys then insert new
        await self._session.execute(
            select(RequestKeyModel.id).where(RequestKeyModel.request_id == request_id)
        )
        await self._session.execute(
            __import__("sqlalchemy").delete(RequestKeyModel).where(RequestKeyModel.request_id == request_id)
        )

        for k in keys:
            self._session.add(
                RequestKeyModel(
                    request_id=req.id,
                    pos=int(k["pos"]),
                    text=str(k["text"]),
                    qty=k.get("qty"),
                    unit=k.get("unit"),
                )
            )

        await self._session.commit()

    async def submit_request(self, request_id: int) -> dict:
        req = await self._session.get(RequestModel, request_id)
        if req is None:
            raise ValueError("not_found")

        # MVP rule: only draft can be submitted
        if str(req.status) != "draft":
            raise ValueError("invalid_state")

        req.status = "confirmed"
        self._session.add(req)
        await self._session.commit()

        return {
            "requestid": int(req.id),
            "newstatus": "confirmed",
            "matchedsuppliers": 0,
            "message": None,
        }


from app.adapters.db.models import AttachmentModel, RequestRecipientModel


class AttachmentRepository:
    def __init__(self, session: AsyncSession) -> None:
        self._session = session

    async def create(
        self,
        *,
        title: str | None,
        original_filename: str,
        content_type: str | None,
        size_bytes: int,
        sha256: str | None,
        storage_key: str | None,
    ) -> dict:
        row = AttachmentModel(
            title=title,
            original_filename=original_filename,
            content_type=content_type,
            size_bytes=int(size_bytes),
            sha256=sha256,
            storage_key=storage_key,
            is_deleted=False,
        )
        self._session.add(row)
        await self._session.commit()
        await self._session.refresh(row)
        return self._to_dict(row)

    async def list(self, *, limit: int, offset: int) -> dict:
        from sqlalchemy import select, func

        total = await self._session.scalar(select(func.count()).select_from(AttachmentModel).where(AttachmentModel.is_deleted == False))  # noqa: E712
        rows = (await self._session.execute(
            select(AttachmentModel)
            .where(AttachmentModel.is_deleted == False)  # noqa: E712
            .order_by(AttachmentModel.id.desc())
            .limit(int(limit))
            .offset(int(offset))
        )).scalars().all()

        return {
            "items": [self._to_dict(r) for r in rows],
            "limit": int(limit),
            "offset": int(offset),
            "total": int(total or 0),
        }

    async def get(self, attachment_id: int) -> dict | None:
        row = await self._session.get(AttachmentModel, attachment_id)
        if row is None or row.is_deleted:
            return None
        return self._to_dict(row)

    async def soft_delete(self, attachment_id: int) -> None:
        row = await self._session.get(AttachmentModel, attachment_id)
        if row is None:
            raise ValueError("not_found")
        row.is_deleted = True
        self._session.add(row)
        await self._session.commit()

    def _to_dict(self, row: AttachmentModel) -> dict:
        return {
            "id": int(row.id),
            "title": row.title,
            "originalfilename": row.original_filename,
            "contenttype": row.content_type,
            "sizebytes": int(row.size_bytes),
            "sha256": row.sha256,
            "storagekey": row.storage_key,
            "isdeleted": bool(row.is_deleted),
            "createdat": row.created_at.isoformat() if row.created_at else None,
        }

    async def upsert_recipients(self, request_id: int, recipients: list[dict]) -> list[dict]:
        \"\"\"MVP: replace recipients list for a request (no supplier<->request validation yet).\"\"\"
        now = datetime.utcnow()

        await self.session.execute(
            delete(RequestRecipientModel).where(RequestRecipientModel.request_id == request_id)
        )

        for rec in recipients:
            self.session.add(
                RequestRecipientModel(
                    request_id=request_id,
                    supplier_id=rec["supplier_id"],
                    selected=rec["selected"],
                    send_status="not_sent",
                    reply_status="no_reply",
                    is_new=True,
                    created_at=now,
                    updated_at=now,
                )
            )

        await self.session.commit()

        res = await self.session.execute(
            select(RequestRecipientModel)
            .where(RequestRecipientModel.request_id == request_id)
            .order_by(RequestRecipientModel.supplier_id.asc())
        )
        items = res.scalars().all()
        return [
            {
                "supplier_id": x.supplier_id,
                "selected": x.selected,
                "send_status": x.send_status,
                "reply_status": x.reply_status,
                "is_new": x.is_new,
            }
            for x in items
        ]